//  PROJECT:     NeoCom.DataManagement(NEOC.DTM)
//  AUTHORS:     Adam Antinoo - adamantinoo.git@gmail.com
//  COPYRIGHT:   (c) 2013-2018 by Dimensinfin Industries, all rights reserved.
//  ENVIRONMENT: Java 1.8 Library.
//  DESCRIPTION: NeoCom project library that comes from the old Models package but that includes much more
//               functionality than the model definitions for the Eve Online NeoCom application.
//               If now defines the pure java code for all the repositories, caches and managers that do
//               not have an specific Android implementation serving as a code base for generic platform
//               development. The architecture model has also changed to a better singleton/static
//               implementation that reduces dependencies and allows separate use of the modules. Still
//               there should be some initialization/configuration code to connect the new library to the
//               runtime implementation provided by the Application.
package org.dimensinfin.eveonline.neocom.database.entities;

import org.dimensinfin.eveonline.neocom.model.NeoComNode;

import com.j256.ormlite.field.DataType;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

// - CLASS IMPLEMENTATION ...................................................................................

/**
 * Credentials are the block of data that stores the new authorization data for the ESI access to Eve Online data servers. The
 * change form CREST/XML has completed and I should not depend on any more data from that interfaces.
 *
 * Credentials are generated by the authorization flow through the CCP servers and connected to the Developer Application that
 * utterly authorizes point access. There are Credentials for the Tranquility production server and for the Singularity testing
 * service that are completely independent.
 *
 * This data should not be exported nor has more validity than to allow back ends to retrieve data on behalf for the user on a
 * periodic basis to speed up data access.
 *
 * There are two variants for using the Credentials. On on single user applications like the one developed for Android this
 * data allows to get repeated access without the need to repeat the login process. ON single user repositories there is no
 * problem sharing the information on different sessions. ONn contrary on the multi user applications like Infinity there
 * should be an isolation level and the Credential should only be used to update cache data.
 *
 * To keep Credential unique I will not use sequence generated ids but the identifier plus the server to use for the authentication.
 * This way I can store credentials for the different eve online servers ans sill only keep one for each server using the pilot
 * unique identifier to isolate this. Using sequence will not avoid having duplicated entries for the same pilot.
 *
 * @author Adam Antinoo
 */
@DatabaseTable(tableName = "Credentials")
public class Credential extends NeoComNode {
	private static final long serialVersionUID = -4248173464157148843L;

	public static String createUniqueIdentifier( final String server, final int identifier ) {
		return server.toUpperCase() + "/" + identifier;
	}

	@DatabaseField(id = true, index = true)
	protected String uniqueCredential = Credential.createUniqueIdentifier("Tranquility", -1);
	@DatabaseField
	protected int accountId = -2;
	@DatabaseField
	private String accountName = "-NAME-";
	@DatabaseField
	public String accessToken = "";
	@DatabaseField
	public String tokenType = "Bearer";
	@DatabaseField
	public String dataSource = "tranquility";
	@DatabaseField(dataType = DataType.LONG_STRING)
	public String scope = "publicData";
	/**
	 * Future expiration Instant time in milliseconds. This field is not required to be stored because the library
	 * will take care of the refresh token expiration times.
	 */
	@DatabaseField
	public long expires = 0;
	@DatabaseField(dataType = DataType.LONG_STRING)
	private String refreshToken = "-TOKEN-";

	// - C O N S T R U C T O R S
	public Credential() {
		super();
	}

	private Credential( final int newAccountIdentifier ) {
		this();
		this.accountId = newAccountIdentifier;
		// Set the default value for the datasource from the current Global configuration.
		//		this.dataSource = accessGlobal().getEveOnlineServerDatasource();
		this.uniqueCredential = Credential.createUniqueIdentifier(this.dataSource, this.accountId);
		//		try {
		//			final Dao<Credential, String> credentialDao = accessGlobal().getNeocomDBHelper().getCredentialDao();
		//			// Try to create the key. It fails then  it was already created.
		//			credentialDao.create(this);
		//		} catch (final SQLException sqle) {
		//			Credential.logger.warn("WR [Credential.<constructor>]> Credential exists. Update values.");
		//			this.store();
		//		}
	}
	//	// - P E R S I S T E N C Y
	//
	//	/**
	//	 * Update the values at the database record.
	//	 */
	//	public Credential store() {
	//		try {
	//			final Dao<Credential, String> credentialDao = accessGlobal().getNeocomDBHelper().getCredentialDao();
	//			credentialDao.createOrUpdate(this);
	//			Credential.logger.info("-- [Credential.store]> Credential data {} successfully.", "UPDATED");
	//		} catch (final SQLException sqle) {
	//			sqle.printStackTrace();
	//		}
	//		return this;
	//	}
	//
	//	public boolean delete() {
	//		try {
	//			final Dao<Credential, String> credentialDao = accessGlobal().getNeocomDBHelper().getCredentialDao();
	//			credentialDao.delete(this);
	//			Credential.logger.info("-- [Credential.store]> Credential data {} successfully.", "DELETED");
	//		} catch (final SQLException sqle) {
	//			sqle.printStackTrace();
	//		}
	//		return true;
	//	}

	// - G E T T E R S   &   S E T T E R S
	public int getAccountId() {
		return accountId;
	}

	public String getAccountName() {
		return accountName;
	}

	public String getName() {
		return accountName;
	}

	public String getAccessToken() {
		return accessToken;
	}

	public String getTokenType() {
		return tokenType;
	}

	public long getExpires() {
		return expires;
	}

	public String getRefreshToken() {
		return refreshToken;
	}

	public String getDataSource() {
		return dataSource.toLowerCase();
	}

	public Credential setAccountId( final int accountId ) {
		this.accountId = accountId;
		return this;
	}

	public Credential setAccountName( final String accountName ) {
		this.accountName = accountName;
		return this;
	}

	public Credential setAccessToken( final String accessToken ) {
		this.accessToken = accessToken;
		return this;
	}

	public Credential setTokenType( final String tokenType ) {
		this.tokenType = tokenType;
		return this;
	}

	public Credential setDataSource( final String dataSource ) {
		this.dataSource = dataSource;
		return this;
	}

	public Credential setExpires( final long expires ) {
		this.expires = expires;
		return this;
	}

	public Credential setRefreshToken( final String refreshToken ) {
		this.refreshToken = refreshToken;
		return this;
	}

	public Credential setScope( final String scope ) {
		this.scope = scope;
		return this;
	}

	@Deprecated
	public boolean isESICompatible() {
		if (accountId < 1) return false;
		if (accessToken.isEmpty()) return false;
		if (refreshToken.isEmpty()) return false;
		return true;
	}

	// - C O R E
	@Override
	public String toString() {
		StringBuffer buffer = new StringBuffer("Credential [");
		buffer.append("[").append(getAccountId()).append("] ");
		buffer.append(" ").append(getAccountName()).append(" ");
		buffer.append("]");
		return buffer.toString();
	}

	// - B U I L D E R
	public static class Builder {
		private Credential onConstruction;

		public Builder( final int account ) {
			this.onConstruction = new Credential(account);
		}

		public Credential build() {
			return this.onConstruction;
		}
	}
}
