package org.dimensinfin.eveonline.neocom.database.entities;

import org.dimensinfin.eveonline.neocom.model.NeoComNode;

import com.j256.ormlite.field.DataType;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

/**
 * Credentials are the block of data that stores the new authorization data for the ESI access to Eve Online data servers. The
 * change form CREST/XML has completed and I should not depend on any more data from that interfaces.
 *
 * Credentials are generated by the authorization flow through the CCP servers and connected to the Developer Application that
 * utterly authorizes point access. There are Credentials for the Tranquility production server and for the Singularity testing
 * service that are completely independent.
 *
 * This data should not be exported nor has more validity than to allow back ends to retrieve data on behalf for the user on a
 * periodic basis to speed up data access.
 *
 * There are two variants for using the Credentials. On on single user applications like the one developed for Android this
 * data allows to get repeated access without the need to repeat the login process. ON single user repositories there is no
 * problem sharing the information on different sessions. ONn contrary on the multi user applications like Infinity there
 * should be an isolation level and the Credential should only be used to update cache data.
 *
 * To keep Credential unique I will not use sequence generated ids but the identifier plus the server to use for the authentication.
 * This way I can store credentials for the different eve online servers ans sill only keep one for each server using the pilot
 * unique identifier to isolate this. Using sequence will not avoid having duplicated entries for the same pilot.
 *
 * @author Adam Antinoo
 */
@DatabaseTable(tableName = "Credentials")
public class Credential extends NeoComNode {
	private static final long serialVersionUID = -4248173464157148843L;

	public static String createUniqueIdentifier( final String server, final int identifier ) {
		return server.toLowerCase() + "/" + identifier;
	}

	@DatabaseField(id = true, index = true)
	protected String uniqueCredential = Credential.createUniqueIdentifier("Tranquility".toLowerCase(), -1);
	@DatabaseField
	public String accessToken = "";
	@DatabaseField
	public String tokenType = "Bearer";
	@DatabaseField
	public String dataSource = "Tranquility".toLowerCase();
	@DatabaseField(dataType = DataType.LONG_STRING)
	public String scope = "publicData";
	@DatabaseField(dataType = DataType.LONG_STRING)
	private String refreshToken = "-TOKEN-";

	@DatabaseField
	protected int accountId = -2;
	@DatabaseField
	private String accountName = "-NAME-";
	@DatabaseField
	protected Double walletBalance = 0.0;
	@DatabaseField
	protected int assetsCount = 0;
	@DatabaseField
	private String raceName;

	// - C O N S T R U C T O R S
	public Credential() {
		super();
	}

	private Credential( final int newAccountIdentifier ) {
		this();
		this.accountId = newAccountIdentifier;
		this.uniqueCredential = Credential.createUniqueIdentifier(this.dataSource, this.accountId);
	}

	// - G E T T E R S   &   S E T T E R S
	public int getAccountId() {
		return accountId;
	}

	public String getAccountName() {
		return accountName;
	}

	public String getName() {
		return accountName;
	}

	public String getRefreshToken() {
		return refreshToken;
	}

	public String getDataSource() {
		return dataSource.toLowerCase();
	}

	public Double getWalletBalance() {
		return walletBalance;
	}

	public Credential setWalletBalance( final Double walletBalance ) {
		this.walletBalance = walletBalance;
		return this;
	}

	public int getAssetsCount() {
		return assetsCount;
	}

	public Credential setAssetsCount( final int assetsCount ) {
		this.assetsCount = assetsCount;
		return this;
	}

	public String getRaceName() {
		return this.raceName;
	}

	public Credential setRaceName( final String raceName ) {
		this.raceName = raceName;
		return this;
	}

	public Credential setAccountId( final int accountId ) {
		this.accountId = accountId;
		return this;
	}

	//	public Credential setAccountName( final String accountName ) {
	//		this.accountName = accountName;
	//		return this;
	//	}

	public Credential setAccessToken( final String accessToken ) {
		this.accessToken = accessToken;
		return this;
	}

	public Credential setTokenType( final String tokenType ) {
		this.tokenType = tokenType;
		return this;
	}

	public Credential setDataSource( final String dataSource ) {
		this.dataSource = dataSource;
		return this;
	}

	//	public Credential setExpires( final long expires ) {
	//		this.expires = expires;
	//		return this;
	//	}

	public Credential setRefreshToken( final String refreshToken ) {
		this.refreshToken = refreshToken;
		return this;
	}

	public Credential setScope( final String scope ) {
		this.scope = scope;
		return this;
	}

	// - C O R E
	@Override
	public String toString() {
		StringBuffer buffer = new StringBuffer("Credential [");
		buffer.append("[").append(getAccountId()).append("] ");
		buffer.append(" ").append(getAccountName()).append(" ");
		buffer.append("]");
		return buffer.toString();
	}

	// - B U I L D E R
	public static class Builder {
		private Credential onConstruction;

		public Builder( final int account ) {
			this.onConstruction = new Credential(account);
		}

		public Builder withCharacterName( final String characterName ) {
			this.onConstruction.accountName = characterName;
			return this;
		}

		public Credential build() {
			return this.onConstruction;
		}
	}
}
