//  PROJECT:     NeoCom.Microservices (NEOC.MS)
//  AUTHORS:     Adam Antinoo - adamantinoo.git@gmail.com
//  COPYRIGHT:   (c) 2017-2018 by Dimensinfin Industries, all rights reserved.
//  ENVIRONMENT: Java 1.8 / SpringBoot-1.3.5 / Angular 5.0
//  DESCRIPTION: This is the SpringBoot MicroServices module to run the backend services to complete the web
//               application based on Angular+SB. This is the web version for the NeoCom Android native
//               application. Most of the source code is common to both platforms and this module includes
//               the source for the specific functionality for the backend services.
package org.dimensinfin.eveonline.neocom.datamngmt;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.dimensinfin.eveonline.neocom.constant.ModelWideConstants;
import org.dimensinfin.eveonline.neocom.database.entity.Credential;
import org.dimensinfin.eveonline.neocom.enums.ELocationType;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdAssets200Ok;
import org.dimensinfin.eveonline.neocom.esiswagger.model.PostCharactersCharacterIdAssetsNames200Ok;
import org.dimensinfin.eveonline.neocom.model.EveItem;
import org.dimensinfin.eveonline.neocom.model.EveLocation;
import org.dimensinfin.eveonline.neocom.model.NeoComAsset;

/**
 * @author Adam Antinoo
 */
// - CLASS IMPLEMENTATION ...................................................................................
public class DownloadManager {
	// - S T A T I C - S E C T I O N ..........................................................................
	private static Logger logger = LoggerFactory.getLogger("DownloadManager");

	// - F I E L D - S E C T I O N ............................................................................
	private transient Credential credential = null;
	//	private transient Dao<NeoComAsset, String> assetDao = null;
	private List<NeoComAsset> unlocatedAssets = null;
	private transient final List<Long> id4Names = new ArrayList<>();

	// - C O N S T R U C T O R - S E C T I O N ................................................................
	public DownloadManager() {
		super();
	}

	public DownloadManager( final Credential credential ) {
		this();
		this.credential = credential;
		// Preload the dao.
//		try {
//			assetDao = new GlobalDataManager().getNeocomDBHelper().getAssetDao();
//		} catch (SQLException sqle) {
//			sqle.printStackTrace();
//		}
	}

	// - M E T H O D - S E C T I O N ..........................................................................

	/**
	 * This downloader will use the new ESI api to get access to the full list of assets for this character.
	 * Once the list is processed we should create an instance as close as possible to the older XML
	 * instances generated by the XML processing.<br>
	 * That instance will then get stored at the database and then we should make the trick of asset
	 * replacing.<br>
	 * The new processing will filter the assets with Unknown locations for a second pass processing so the
	 * final list on the database will have the correct parentship hierarchy set up.<br>
	 * <br>
	 * The assets downloaded are being written to a special set of records in the User database with an special
	 * <code>ownerid</code> so we can work with a new set of records for an specific Character without
	 * disturbing the access to the old asset list for the same Character. After all the assets are processed
	 * and stored in the database we remove the old list and replace the owner of the new list to the right one.<br>
	 */
	public void downloadPilotAssetsESI() {
		DownloadManager.logger.info(">> [AssetsManager.downloadPilotAssetsESI]");
		try {
			// Clear any previous record with owner -1 from database.
			new GlobalDataManager().getNeocomDBHelper().clearInvalidRecords(credential.getAccountId());
//			synchronized (dbConn) {
//				dbConn.clearInvalidRecords(credential.getAccountId());
//			}
			// Download the list of assets.
			final List<GetCharactersCharacterIdAssets200Ok> assetOkList = ESINetworkManager.getCharactersCharacterIdAssets(credential.getAccountId(), credential.getRefreshToken(), null);
			unlocatedAssets = new ArrayList<NeoComAsset>();
			//				List<Asset> assets = response.getAll();
			// Assets may be parent of other assets so process them recursively if the hierarchical mode is selected.
			for (final GetCharactersCharacterIdAssets200Ok assetOk : assetOkList) {
				//	try {
				// Convert the asset from the OK format to a MVC compatible structure.
				//						final NeoComAsset myasset = modelMapper.map(assetOk, NeoComAsset.class);
				final NeoComAsset myasset = this.convert2AssetFromESI(assetOk);
				//					if ( null != parent ) {
				//						//			myasset.setParent(parent);
				//						myasset.setParentContainer(parent);
				//						// Set the location to the parent's location is not set.
				//						if ( myasset.getLocationID() == -1 ) {
				//							myasset.setLocationID(parent.getLocationID());
				//						}
				//					}
				// Only search names for containers and ships.
				if (myasset.isShip()) {
					downloadAssetEveName(myasset.getAssetId());
				}
				if (myasset.isContainer()) {
					downloadAssetEveName(myasset.getAssetId());
				}
				try {
					//			final Dao<NeoComAsset, String> assetDao = ModelAppConnector.getSingleton().getDBConnector().getAssetDAO();
					//					this.accessDaos();
					//						final HashSet<Asset> children = new HashSet<Asset>(eveAsset.getAssets());
					//						if ( children.size() > 0 ) {
					//							myasset.setContainer(true);
					//						}
					if (myasset.getCategory().equalsIgnoreCase("Ship")) {
						myasset.setShip(true);
					}
					if (myasset.getCategory().equalsIgnoreCase("Blueprint")) {
						//			myasset.setBlueprintType();
					}
					myasset.setOwnerID(credential.getAccountId() * -1);
					//					myasset.store();
					// With assets separate the update from the creation because they use a generated unique key.
					new GlobalDataManager().getNeocomDBHelper().getAssetDao().create(myasset);
					// Check the asset location. The location can be a known game station, a known user structure, another asset
					// or an unknown player structure. Check which one is this location.
					EveLocation targetLoc = new GlobalDataManager().searchLocation4Id(myasset.getLocationId());
					if (targetLoc.getTypeID() == ELocationType.UNKNOWN) {
						// Add this asset to the list of items to be reprocessed.
						unlocatedAssets.add(myasset);
					}
					// Process all the children and convert them to assets.
					//						if ( children.size() > 0 ) {
					//							for (final Asset childAsset : children) {
					//								this.processAsset(childAsset, myasset);
					//							}
					//						}
					DownloadManager.logger.info("-- Wrote asset to database id [" + myasset.getAssetId() + "]");
					//					} catch (final SQLException sqle) {
					//						DownloadManager.logger.error("E> [AssetsManager.processAsset]Unable to create the new asset ["
					//								+ myasset.getAssetId() + "]. " + sqle.getMessage());
					//						sqle.printStackTrace();
					//					}
				} catch (final RuntimeException rtex) {
					rtex.printStackTrace();
				} catch (final Exception ex) {
					ex.printStackTrace();
				}
			}
			// Second pass. All the assets in unknown locations should be readjusted for hierarchy changes.
			for (NeoComAsset asset : unlocatedAssets) {
				this.validateLocation(asset);
			}
			// Assign the assets to the pilot.
			new GlobalDataManager().getNeocomDBHelper().replaceAssets(credential.getAccountId());
			// Remove from memory the managers that contain now stale data.
			//TODO Removed until this is checked if required.
//			GlobalDataManager.dropAssetsManager(credential.getAccountId());
		} catch (final Exception ex) {
			ex.printStackTrace();
		}
		DownloadManager.logger.info("<< [AssetsManager.downloadPilotAssetsESI]");
	}

	//--- P R I V A T E   M E T H O D S
	private NeoComAsset convert2AssetFromESI( final GetCharactersCharacterIdAssets200Ok asset200Ok ) {
		// Create the asset from the API asset.
		final NeoComAsset newAsset = new NeoComAsset(asset200Ok.getTypeId())
				.setAssetId(asset200Ok.getItemId());
		//	.setTypeId(asset200Ok.getTypeId());
		Long locid = asset200Ok.getLocationId();
		if (null == locid) {
			locid = (long) -2;
		}
		newAsset.setLocationId(locid)
				.setLocationType(asset200Ok.getLocationType())
				.setQuantity(asset200Ok.getQuantity())
				.setFlag(asset200Ok.getLocationFlag())
				.setSingleton(asset200Ok.getIsSingleton());
		// Get access to the Item and update the copied fields.
		final EveItem item = new GlobalDataManager().searchItem4Id(newAsset.getTypeId());
		if (null != item) {
			try {
				newAsset.setName(item.getName());
				newAsset.setCategory(item.getCategory());
				newAsset.setGroupName(item.getGroupName());
				newAsset.setTech(item.getTech());
				if (item.isBlueprint()) {
					//			newAsset.setBlueprintType(eveAsset.getRawQuantity());
				}
			} catch (RuntimeException rtex) {
			}
		}
		// Add the asset value to the database.
		newAsset.setIskValue(this.calculateAssetValue(newAsset));
		return newAsset;
	}

	private synchronized double calculateAssetValue( final NeoComAsset asset ) {
		// Skip blueprints from the value calculations
		double assetValueISK = 0.0;
		if (null != asset) {
			EveItem item = asset.getItem();
			if (null != item) {
				String category = item.getCategory();
				String group = item.getGroupName();
				if (null != category) if (!category.equalsIgnoreCase(ModelWideConstants.eveglobal.Blueprint)) {
					// Add the value and volume of the stack to the global result.
					long quantity = asset.getQuantity();
					double price = asset.getItem().getHighestBuyerPrice().getPrice();
					assetValueISK = price * quantity;
				}
			}
		}
		return assetValueISK;
	}

	/**
	 * Checks if the Location can be found on the two lists of Locations, the CCP game list or the player
	 * compiled list. If the Location can't be found on any of those lists then it can be another asset
	 * (Container, Ship, etc) or another player/corporation structure resource that is not listed on the asset
	 * list.
	 */
	private ELocationType validateLocation( final NeoComAsset asset ) {
		long targetLocationid = asset.getLocationId();
		EveLocation targetLoc = new GlobalDataManager().searchLocation4Id(targetLocationid);
		if (targetLoc.getTypeID() == ELocationType.UNKNOWN) {
			try {
				// Need to check if asset or unreachable location.
				NeoComAsset target = new GlobalDataManager().getNeocomDBHelper().getAssetDao()
						.queryForId(Long.valueOf(targetLocationid).toString());
				if (null == target)
					return ELocationType.UNKNOWN;
				else {
					// Change the asset parentship and update the asset location with the location of the parent.
					asset.setParentId(targetLocationid);
					//// search for the location of the parent.
					//ELocationType parentLocationType = ModelAppConnector.getSingleton().getCCPDBConnector().searchLocationbyID(target.getLocationID()).getTypeId();
					//if(parentLocationType!=ELocationType.UNKNOWN)
					asset.setLocationId(target.getLocationId());
					asset.setDirty(true);
				}
			} catch (SQLException sqle) {
				return ELocationType.UNKNOWN;
			}
			return ELocationType.UNKNOWN;
		} else
			return targetLoc.getTypeID();
	}

	/**
	 * Aggregates ids for some of the assets until it reached 10 and then posts and update for the whole batch.
	 */
	private void downloadAssetEveName( final long assetId ) {
		id4Names.add(assetId);
		if (id4Names.size() > 9) {
			postUserLabelNameDownload();
			id4Names.clear();
		}
	}

	private void postUserLabelNameDownload() {
		// Launch the download of the names block.
		final List<Long> idList = new ArrayList<>();
		idList.addAll(id4Names);
		GlobalDataManager.submitJob2Download(() -> {
			// Copy yhe list of assets to local to allow parallel use.
			final List<Long> localIdList = new ArrayList<>();
			localIdList.addAll(idList);
			try {
				final List<PostCharactersCharacterIdAssetsNames200Ok> itemNames = ESINetworkManager.postCharactersCharacterIdAssetsNames(credential.getAccountId(), localIdList, credential.getRefreshToken(), null);
				for (final PostCharactersCharacterIdAssetsNames200Ok name : itemNames) {
					final List<NeoComAsset> assetsMatch = new GlobalDataManager().getNeocomDBHelper().getAssetDao().queryForEq("assetId",
							name.getItemId());
					for (NeoComAsset asset : assetsMatch) {
						logger.info("-- [DownloadManager.downloadAssetEveName]> Setting UserLabel name {} for asset {}.", name
								.getName(), name.getItemId());
						asset.setUserLabel(name.getName())
								.store();
					}
				}
			} catch (SQLException sqle) {
				sqle.printStackTrace();
			}
		});
	}

	// --- D E L E G A T E D   M E T H O D S
	@Override
	public String toString() {
		if (null != credential) return new StringBuffer("DownloadManager [")
				.append("owner:").append(credential.getAccountId()).append(" ")
				.append("]")
				.append("->").append(super.toString())
				.toString();
		else return new StringBuffer("DownloadManager []").toString();
	}
}

// - UNUSED CODE ............................................................................................
//[01]
