//  PROJECT:     NeoCom.DataManagement(NEOC.DTM)
//  AUTHORS:     Adam Antinoo - adamantinoo.git@gmail.com
//  COPYRIGHT:   (c) 2013-2018 by Dimensinfin Industries, all rights reserved.
//  ENVIRONMENT: Java 1.8 Library.
//  DESCRIPTION: NeoCom project library that comes from the old Models package but that includes much more
//               functionality than the model definitions for the Eve Online NeoCom application.
//               If now defines the pure java code for all the repositories, caches and managers that do
//               not have an specific Android implementation serving as a code base for generic platform
//               development. The architecture model has also changed to a better singleton/static
//               implementation that reduces dependencies and allows separate use of the modules. Still
//               there should be some initialization/configuration code to connect the new library to the
//               runtime implementation provided by the Application.
package org.dimensinfin.eveonline.neocom.entities;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.datatype.joda.JodaModule;
import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.field.DataType;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.dimensinfin.core.interfaces.ICollaboration;
import org.dimensinfin.eveonline.neocom.constant.ModelWideConstants;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdAssets200Ok;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdBlueprints200Ok;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCorporationsCorporationIdAssets200Ok;
import org.dimensinfin.eveonline.neocom.exception.NeoComRuntimeException;
import org.dimensinfin.eveonline.neocom.interfaces.ILocatableAsset;
import org.dimensinfin.eveonline.neocom.model.ANeoComEntity;
import org.dimensinfin.eveonline.neocom.model.EveItem;
import org.dimensinfin.eveonline.neocom.model.EveLocation;
import org.dimensinfin.eveonline.neocom.model.NeoComNode;

//- CLASS IMPLEMENTATION ...................................................................................

/**
 * Assets are collections of <code>EveItem</code>s of the same type and characteristics that are grouped on
 * game stacks and that belong to a single <code>EveChar</code> and that are located on a
 * <code>EveLocation</code>. Most of the data for an asset can be found on those classes but is being added to
 * the persistence implementation to allow DAO searches and easier database interaction so the asset
 * management that is a quite memory intensive activity may be performed with the few memory possible.<br>
 * The identifier information and the key dta are downloaded from CCP data with an API call. The data is then
 * expanded and some of the assets are grouped while being stored on the database with a neutral character
 * identifier until the end of the processing when all those assets are transferred to the correct owner.<br>
 * Persistence is implemented on the "Assets" table on the <code>evedroid.db</code> user database.
 * @author Adam Antinoo
 */

@DatabaseTable(tableName = "Assets")
public class NeoComAsset extends ANeoComEntity implements ILocatableAsset {
	// - S T A T I C - S E C T I O N ..........................................................................
	private static final long serialVersionUID = -2662145568311324496L;
	private static Logger logger = LoggerFactory.getLogger("NeoComAsset");

	private static final ObjectMapper jsonMapper = new ObjectMapper();

	static {
		jsonMapper.enable(SerializationFeature.INDENT_OUTPUT);
		jsonMapper.registerModule(new JodaModule());
		// Add our own serializers.
		SimpleModule neocomSerializerModule = new SimpleModule();
		neocomSerializerModule.addSerializer(EveItem.class, new EveItemSerializer());
		jsonMapper.registerModule(neocomSerializerModule);
	}

	// - F I E L D - S E C T I O N ............................................................................
	/**
	 * This is a generated identifier to allow having duplicated asset numbers when processing updates. This is
	 * the primary key identifier and it is generated by an incremental sequence.
	 */
	@DatabaseField(index = true, generatedId = true)
	protected long id = -2;
	// - A P I   C C P   F I E L D S
	@DatabaseField(index = true)
	private long assetId;
	@DatabaseField
	private int typeId;
	@DatabaseField
	private int quantity = 0;
	@DatabaseField(index = true)
	private long locationId = -1;
	@DatabaseField(dataType = DataType.ENUM_STRING)
	private GetCharactersCharacterIdAssets200Ok.LocationTypeEnum locationType = null;
	@DatabaseField(dataType = DataType.ENUM_STRING)
	private GetCharactersCharacterIdAssets200Ok.LocationFlagEnum locationFlag = null;
	@DatabaseField
	private boolean isSingleton = false;
	@DatabaseField
	private long parentAssetId = -1;

	//- D E R I V E D   F I E L D S
	/**
	 * Here starts the fields that come form item data but useful for search operations.
	 */
	@DatabaseField
	private long ownerId = -1;
	@DatabaseField
	private String name = null;
	@DatabaseField(index = true)
	private String category = null;
	@DatabaseField(index = true)
	private String groupName = null;
	@DatabaseField
	private String tech = null;
	@DatabaseField
	private boolean blueprintFlag = false;
	@DatabaseField
	private String userLabel = null;
	@DatabaseField
	private boolean shipFlag = false;
	@DatabaseField
	private boolean containerFlag = false;
	@DatabaseField
	private double iskValue = 0.0;

	//- S P E C I A L   F I E L D S
	private EveItem item = null;
	@DatabaseField(dataType = DataType.LONG_STRING, useGetSet = true)
	@JsonIgnore
	private String itemSerialized;

	// - C A C H E D   F I E L D S
	private transient NeoComAsset parentAssetCache = null;
	private transient EveLocation locationCache = null;
//	private transient EveItem itemCache = null;

	// - C O N S T R U C T O R - S E C T I O N ................................................................
	public NeoComAsset() {
		super();
		id = -2;
		locationId = -1;
		locationType = null;
	}

	/**
	 * Initialize the asset with a type identifier. This should fire the load of the Eve Item.
	 * @param typeIdentifier
	 */
	public NeoComAsset( final int typeIdentifier ) {
		this();
		this.setTypeId(typeIdentifier);
	}

	// - M E T H O D - S E C T I O N ..........................................................................
	@JsonIgnore
	public String getItemSerialized() {
		try {
			final String serialized = jsonMapper.writeValueAsString(this.item);
			return serialized;
		} catch ( JsonProcessingException e ) {
			e.printStackTrace();
			return "";
		}
	}

	public void setItemSerialized( String personstr ) {
		try {
//			final String contents = databaseResults.getString(columnPos);
			final EveItem neweveitem = jsonMapper.readValue(personstr, EveItem.class);
			this.item = neweveitem;
//			return neweveitem;
		} catch ( IOException e ) {
			e.printStackTrace();
//			return null;
		}
	}

	//--- I C O L L A B O R A T I O N   I N T E R F A C E

	/**
	 * Assets should collaborate to the model adding their children. Most of the assets will not have children
	 * but the containers that maybe will use this code or be created as other kind of specialized asset.
	 */
	@Override
	public List<ICollaboration> collaborate2Model( final String variant ) {
		final ArrayList<ICollaboration> results = new ArrayList<ICollaboration>();
		return results;
	}

	//--- I D A T A B A S E E N T I T Y   I N T E R F A C E

	/**
	 * Update the values at the database record.
	 */
	public NeoComAsset store() {
		try {
			final Dao<NeoComAsset, String> assetDao = accessGlobal().getNeocomDBHelper().getAssetDao();
			assetDao.update(this);
			logger.info("-- [NeoComAsset.store]> NeoComAsset data updated successfully.");
		} catch ( final SQLException sqle ) {
			sqle.printStackTrace();
		}
		return this;
	}

	//--- G E T T E R S   &   S E T T E R S
	public long getDAOId() {
		return id;
	}

	public long getAssetId() {
		return assetId;
	}

	public int getTypeId() {
		return typeId;
	}

	public int getQuantity() {
		return quantity;
	}

	public long getOwnerId() {
		return ownerId;
	}

	public GetCharactersCharacterIdAssets200Ok.LocationFlagEnum getLocationFlag() {
		return locationFlag;
	}

	//	@Override
	public GetCharactersCharacterIdAssets200Ok.LocationTypeEnum getLocationType() {
		return this.locationType;
	}

	public String getCategoryName() {
		if ( null == this.category ) return "NOCAT";
		else return this.category;
	}

	public String getGroupName() {
		if ( null == this.groupName ) return "NOGROUP";
		else return this.groupName;
	}

	@Deprecated
	public double getIskValue() {
		return iskValue;
	}

	/**
	 * This has not to go to the item to get the information since this is copied to the Asset at creation time.
	 * @return
	 */
	public String getItemName() {
		return this.getName();
	}

	/**
	 * Return the location id of the asset. If the asset is in a container then the location is lost and the
	 * value is -1. In that cases we should search for the location on the parent asset if that exists.
	 */
	@Override
	public long getLocationId() {
		return locationId;
	}

	@Deprecated
	public String getName() {
		return name;
	}

	/**
	 * The old implementation is deprecated because forced the Market data fetch. Now it should return the declared price calculated
	 * when the asset was generated.
	 * @return
	 */
	public double getPrice() {
		return this.iskValue;
	}

	public String getTech() {
		return this.getItem().getTech();
	}

	public String getUserLabel() {
		return userLabel;
	}

	public boolean isBlueprint() {
		return blueprintFlag;
	}

	public boolean isContainer() {
		return this.containerFlag;
	}

	public boolean isPackaged() {
		return !isSingleton;
	}

	public boolean isShip() {
		return shipFlag;
	}

	public void setId( final long id ) {
		this.id = id;
	}

	public NeoComAsset setAssetId( final long assetIdentifier ) {
		this.assetId = assetIdentifier;
		return this;
	}

	public void setBlueprintType( final int rawQuantity ) {
		if ( -1 == rawQuantity ) {
			this.setName(name + " (BPO)");
		} else {
			this.setName(name + " (BPC)");
		}
		blueprintFlag = true;
		this.containerFlag = this.checkIfContainer();
	}

	public void setCategory( final String category ) {
		if ( null != category ) {
			this.category = category;
			if ( category.equalsIgnoreCase(ModelWideConstants.eveglobal.Ship) ) {
				shipFlag = true;
			}
		}
	}

	public void setContainer( final boolean value ) {
		containerFlag = value;
	}

	@Override
	public NeoComAsset setLocationFlag( final GetCharactersCharacterIdAssets200Ok.LocationFlagEnum newFlag ) {
		this.locationFlag = newFlag;
		return this;
	}

	@Override
	public NeoComAsset setLocationFlag( final GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum newFlag ) {
		this.locationFlag = GetCharactersCharacterIdAssets200Ok.LocationFlagEnum.valueOf(newFlag.name());
		return this;
	}

	public NeoComAsset setLocationFlag( final GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum newFlag ) {
		this.locationFlag = GetCharactersCharacterIdAssets200Ok.LocationFlagEnum.valueOf(newFlag.name());
		return this;
	}

	public void setGroupName( final String name ) {
		groupName = name;
	}

	public void setIskValue( final double iskvalue ) {
		iskValue = iskvalue;
	}

	@Override
	public NeoComAsset setLocationId( final long location ) {
		locationId = location;
		locationCache = null;
		return this;
	}

	@Override
	public NeoComAsset setLocationType( final GetCharactersCharacterIdAssets200Ok.LocationTypeEnum locationType ) {
		this.locationType = locationType;
		return this;
	}

	public NeoComAsset setLocationType( final GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum locationType ) {
		this.locationType = GetCharactersCharacterIdAssets200Ok.LocationTypeEnum.valueOf(locationType.name());
		return this;
	}

	public NeoComAsset setName( final String name ) {
		this.name = name;
		this.containerFlag = this.checkIfContainer();
		return this;
	}

	public void setOwnerId( final long ownerId ) {
		this.ownerId = ownerId;
	}

	public NeoComAsset setQuantity( final int count ) {
		quantity = count;
		return this;
	}

	@Deprecated
	public void setShip( final boolean value ) {
		shipFlag = value;
	}

	public void setAsShip( final boolean value ) {
		shipFlag = value;
	}

	@Deprecated
	public void setShipFlag( final boolean shipFlag ) {
		this.shipFlag = shipFlag;
	}

	public NeoComAsset setSingleton( final boolean newSingleton ) {
		isSingleton = newSingleton;
		return this;
	}

	public void setTech( final String newTech ) {
		tech = newTech;
	}

	/**
	 * Durent the new implementation when the asset gets the item identifier we should go to the Eve Item provider and get a fresh
	 * copy to be inserted serialized on the database.
	 * @param newTypeId
	 * @return
	 */
	public NeoComAsset setTypeId( final int newTypeId ) {
		typeId = newTypeId;
		// Get the item and store on the database field.
		this.item = accessGlobal().searchItem4Id(typeId);
		// Copy the item fields to the asset fields to get them ready for use.
		this.name = this.getItem().getName();
		this.category = this.getItem().getCategoryName();
		this.groupName = this.getItem().getGroupName();
		this.tech = this.getItem().getTech();
		this.containerFlag = this.checkIfContainer();
		return this;
	}

	public NeoComAsset setUserLabel( final String label ) {
		if ( null != label ) {
			userLabel = label;
		}
		return this;
	}

	//--- V I R T U A L   G E T T E R S

	/**
	 * New optimization will leave this field for lazy evaluation. So check if this is empty before getting any
	 * access and if so download from the Item Cache.
	 */
	public EveItem getItem() {
		try {
			if ( null == item ) {
				item = accessGlobal().searchItem4Id(typeId);
			}
		} catch ( NeoComRuntimeException neoe ) {
			item = new EveItem();
		}
		return item;
	}

	@Override
	public EveLocation getLocation() {
		try {
			if ( null == locationCache ) {
				locationCache = accessGlobal().searchLocation4Id(locationId);
			}
		} catch ( NeoComRuntimeException neoe ) {
			locationCache = new EveLocation();
		}
		return locationCache;
	}

	@JsonIgnore
	public String getRegion() {
		return this.getLocation().getRegion();
	}

	@JsonIgnore
	public boolean checkIfContainer() {
		if ( this.isBlueprint() ) return false;
		// Use a list of types to set what is a container
		if ( this.getTypeId() == 11488 ) return true;
		if ( this.getTypeId() == 11489 ) return true;
		if ( this.getTypeId() == 11490 ) return true;
		if ( this.getTypeId() == 17363 ) return true;
		if ( this.getTypeId() == 17364 ) return true;
		if ( this.getTypeId() == 17365 ) return true;
		if ( this.getTypeId() == 17366 ) return true;
		if ( this.getTypeId() == 17367 ) return true;
		if ( this.getTypeId() == 17368 ) return true;
		if ( this.getTypeId() == 2263 ) return true;
		if ( this.getTypeId() == 23 ) return true;
		if ( this.getTypeId() == 24445 ) return true;
		if ( this.getTypeId() == 28570 ) return true;
		if ( this.getTypeId() == 3293 ) return true;
		if ( this.getTypeId() == 3296 ) return true;
		if ( this.getTypeId() == 3297 ) return true;
		if ( this.getTypeId() == 33003 ) return true;
		if ( this.getTypeId() == 33005 ) return true;
		if ( this.getTypeId() == 33007 ) return true;
		if ( this.getTypeId() == 33009 ) return true;
		if ( this.getTypeId() == 33011 ) return true;
		if ( this.getTypeId() == 3465 ) return true;
		if ( this.getTypeId() == 3466 ) return true;
		if ( this.getTypeId() == 3467 ) return true;
		if ( this.getTypeId() == 3468 ) return true;
		if ( this.getTypeId() == 41567 ) return true;
		if ( this.getTypeId() == 60 ) return true; // Asset Safety Wrap
		if ( this.getItemName().contains("Container") ) return true;
		if ( this.getItemName().contains("Wrap") ) return true;
		return false;
	}

	// --- I L O C A T A B L E    I N T E R F A C E

	/**
	 * This method usually return the parent container of an asset. This is valid when the asset is inside a
	 * container or a ship or any other asset, but when the asset is located on other corporation POCO or other
	 * unknown or unaccessible asset then this method fails to get the parent asset. <br>
	 * In that case we should replace the parent pointer to a new location pointer that gets stored into our new
	 * Locations table. With that change assets will be reallocated to a valid place and all code will
	 * understand the changes and behave correctly.
	 */
	@Override
	public NeoComAsset getParentContainer() {
		if ( parentAssetId > 0 ) if ( null == parentAssetCache ) {
			// Search for the parent asset. If not found then go to the transformation method.
			try {
				parentAssetCache = accessGlobal().getNeocomDBHelper().getAssetDao()
						.queryForId(Long.valueOf(parentAssetId).toString());
			} catch ( SQLException sqle ) {
				return null;
			}
		}
		return parentAssetCache;
	}

	@Override
	public long getParentContainerId() {
		return parentAssetId;
	}

	@Override
	public boolean hasParent() {
		if ( parentAssetId > 0 )
			return true;
		else
			return false;
	}

	@Override
	public void setParentContainer( final NeoComAsset newParent ) {
		if ( null != newParent ) {
			parentAssetCache = newParent;
			parentAssetId = newParent.getAssetId();
			// Trigger an update of the record at the database.
			this.store();
		}
	}

	@Override
	public void setParentId( final long pid ) {
		parentAssetId = pid;
	}

	/**
	 * Try to reduce the calls to methods to compose this information since that affects the code to be run.
	 */
	@Override
	public String toString() {
		final StringBuffer buffer = new StringBuffer("NeoComAsset [");
		buffer.append("#").append(typeId).append(" - ").append(this.getName()).append(" ");
		if ( null != this.getUserLabel() ) {
			buffer.append("[").append(this.getUserLabel()).append("] ");
		}
		buffer.append("itemID:").append(assetId).append(" ");
		buffer.append("locationID:").append(locationId).append(" ");
		buffer.append("containerID:").append(parentAssetId).append(" ");
		buffer.append("ownerId:").append(ownerId).append(" ");
		buffer.append("quantity:").append(quantity).append(" ");
		buffer.append("]\n");
		return buffer.toString();
	}

	/**
	 * Replaces a non reachable parent asset into an Unknown Location.
	 */
	private EveLocation moveAssetToUnknown( final long newlocationid ) {
		final EveLocation newundefloc = new EveLocation();
		//		newundefloc.setId(newlocationid);
		newundefloc.setRegion("SPACE");
		newundefloc.setSystem("Undefined");
		newundefloc.setStation("Station#" + newlocationid);
		// Save this new location ot the database.
		//		try {
		//			Dao<EveLocation, String> locationDao = AppConnector.getDBConnector().getLocationDAO();
		//			// Try to create the pair. It fails then  it was already created.
		//			locationDao.createOrUpdate(newundefloc);
		//		} catch (final SQLException sqle) {
		//			sqle.printStackTrace();
		//			this.store(true);
		//		}
		return newundefloc;
	}

	// - CLASS IMPLEMENTATION ...................................................................................
	public static class EveItemSerializer extends JsonSerializer<EveItem> {
		// - F I E L D - S E C T I O N ............................................................................

		// - M E T H O D - S E C T I O N ..........................................................................
		@Override
		public void serialize( final EveItem value, final JsonGenerator jgen, final SerializerProvider provider )
				throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			jgen.writeStringField("jsonClass", value.getJsonClass());
			jgen.writeNumberField("typeId", value.getTypeId());
			jgen.writeStringField("name", value.getName());
			jgen.writeNumberField("categoryId", value.getCategoryId());
			jgen.writeStringField("categoryName", value.getCategoryName());
			jgen.writeNumberField("groupId", value.getGroupId());
			jgen.writeStringField("groupName", value.getGroupName());
			jgen.writeNumberField("baseprice", value.getBaseprice());
			jgen.writeNumberField("price", value.getPrice());
			jgen.writeStringField("tech", value.getTech());
			jgen.writeNumberField("volume", value.getVolume());
			jgen.writeStringField("industryGroup", value.getIndustryGroup().name());
			jgen.writeStringField("hullGroup", value.getHullGroup());
			try {
				jgen.writeObjectField("lowestSellerPrice", value.getLowestSellerPrice());
			} catch ( ExecutionException e ) {
			} catch ( InterruptedException e ) {
			}
			try {
				jgen.writeObjectField("highestBuyerPrice", value.getHighestBuyerPrice());
			} catch ( ExecutionException e ) {
			} catch ( InterruptedException e ) {
			}
			jgen.writeEndObject();
		}
	}
	// ..........................................................................................................
}
//- UNUSED CODE ............................................................................................
