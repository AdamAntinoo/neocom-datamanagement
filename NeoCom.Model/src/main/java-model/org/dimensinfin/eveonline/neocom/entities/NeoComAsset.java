//  PROJECT:     NeoCom.DataManagement(NEOC.DTM)
//  AUTHORS:     Adam Antinoo - adamantinoo.git@gmail.com
//  COPYRIGHT:   (c) 2013-2018 by Dimensinfin Industries, all rights reserved.
//  ENVIRONMENT: Java 1.8 Library.
//  DESCRIPTION: NeoCom project library that comes from the old Models package but that includes much more
//               functionality than the model definitions for the Eve Online NeoCom application.
//               If now defines the pure java code for all the repositories, caches and managers that do
//               not have an specific Android implementation serving as a code base for generic platform
//               development. The architecture model has also changed to a better singleton/static
//               implementation that reduces dependencies and allows separate use of the modules. Still
//               there should be some initialization/configuration code to connect the new library to the
//               runtime implementation provided by the Application.
package org.dimensinfin.eveonline.neocom.entities;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.field.DataType;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.dimensinfin.core.interfaces.ICollaboration;
import org.dimensinfin.eveonline.neocom.constant.ModelWideConstants;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdAssets200Ok;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdBlueprints200Ok;
import org.dimensinfin.eveonline.neocom.exception.NeoComRuntimeException;
import org.dimensinfin.eveonline.neocom.interfaces.ILocatableAsset;
import org.dimensinfin.eveonline.neocom.model.EveItem;
import org.dimensinfin.eveonline.neocom.model.EveLocation;
import org.dimensinfin.eveonline.neocom.model.NeoComNode;

//- CLASS IMPLEMENTATION ...................................................................................

/**
 * Assets are collections of <code>EveItem</code>s of the same type and characteristics that are grouped on
 * game stacks and that belong to a single <code>EveChar</code> and that are located on a
 * <code>EveLocation</code>. Most of the data for an asset can be found on those classes but is being added to
 * the persistence implementation to allow DAO searches and easier database interaction so the asset
 * management that is a quite memory intensive activity may be performed with the few memory possible.<br>
 * The identifier information and the key dta are downloaded from CCP data with an API call. The data is then
 * expanded and some of the assets are grouped while being stored on the database with a neutral character
 * identifier until the end of the processing when all those assets are transferred to the correct owner.<br>
 * Persistence is implemented on the "Assets" table on the <code>evedroid.db</code> user database.
 * @author Adam Antinoo
 */

@DatabaseTable(tableName = "Assets")
public class NeoComAsset extends NeoComNode implements ILocatableAsset {
	// - S T A T I C - S E C T I O N ..........................................................................
	private static final long serialVersionUID = -2662145568311324496L;
	private static Logger logger = LoggerFactory.getLogger("NeoComAsset");

	// - F I E L D - S E C T I O N ............................................................................
	/**
	 * This is a generated identifier to allow having duplicated asset numbers when processing updates. This is
	 * the primary key identifier and it is generated by an incremental sequence.
	 */
	@DatabaseField(index = true, generatedIdSequence = "asset_id_seq")
	protected long id = -2;
	// - A P I   C C P   F I E L D S
	@DatabaseField(index = true)
	private long assetId;
	@DatabaseField(index = true)
	private int typeId;
	@DatabaseField
	private int quantity = 0;
	@DatabaseField(index = true)
	private long locationId = -1;
	@DatabaseField(dataType = DataType.ENUM_STRING)
	private GetCharactersCharacterIdAssets200Ok.LocationTypeEnum locationType = null;
	@DatabaseField(dataType = DataType.ENUM_STRING)
	private GetCharactersCharacterIdAssets200Ok.LocationFlagEnum locationFlag = null;
	@DatabaseField
	private boolean isSingleton = false;
	@DatabaseField
	private long parentAssetId = -1;

	//- D E R I V E D   F I E L D S
	/**
	 * Here starts the fields that come form item data but useful for search operations.
	 */
	@DatabaseField
	private long ownerId = -1;
	@DatabaseField
	private String name = null;
	@DatabaseField(index = true)
	private String category = null;
	@DatabaseField(index = true)
	private String groupName = null;
	@DatabaseField
	private String tech = null;
	@DatabaseField
	private boolean blueprintFlag = false;
	@DatabaseField
	private String userLabel = null;
	@DatabaseField
	private boolean shipFlag = false;
	@DatabaseField
	private boolean containerFlag = false;
	@DatabaseField
	private double iskValue = 0.0;

	// - C A C H E D   F I E L D S
	private transient NeoComAsset parentAssetCache = null;
	private transient EveLocation locationCache = null;
	private transient EveItem itemCache = null;

	// - C O N S T R U C T O R - S E C T I O N ................................................................
	public NeoComAsset() {
		super();
		//		this.jsonClass = "NeoComAsset";
		id = -2;
		locationId = -1;
		locationType = null;
	}

	public NeoComAsset(final int typeIdentifier) {
		this();
		typeId = typeIdentifier;
	}

	// - M E T H O D - S E C T I O N ..........................................................................

	/**
	 * Assets should collaborate to the model adding their children. Most of the assets will not have children
	 * but the containers that maybe will use this code or be created as other kind of specialized asset.
	 */
	@Override
	public List<ICollaboration> collaborate2Model(final String variant) {
		final ArrayList<ICollaboration> results = new ArrayList<ICollaboration>();
		//		results = this.concatenateChildren(results, this.getChildren());
		return results;
	}

	/**
	 * Update the values at the database record.
	 */
	public NeoComAsset store() {
		try {
			final Dao<NeoComAsset, String> assetDao = accessGlobal().getNeocomDBHelper().getAssetDao();
			assetDao.update(this);
			logger.info("-- [NeoComAsset.store]> NeoComAsset data updated successfully.");
		} catch ( final SQLException sqle ) {
			sqle.printStackTrace();
		}
		return this;
	}

	public long getAssetId() {
		return assetId;
	}

	//	@Deprecated
	//	public String getCategory() {
	//		if ( null == category ) return "NOCAT";
	//		return category;
	//	}

	public String getCategoryName() {
		if ( null == category ) return "NOCAT";
		return category;
	}

	//	@Deprecated
	//	public int getContentCount() {
	//		return 0;
	//	}

	public long getDAOID() {
		return id;
	}

	public GetCharactersCharacterIdAssets200Ok.LocationFlagEnum getFlag() {
		return locationFlag;
	}

	//	@Override
	public GetCharactersCharacterIdAssets200Ok.LocationTypeEnum getLocationType() {
		return this.locationType;
	}

	public String getGroupName() {
		return groupName;
	}

	public double getIskValue() {
		return iskValue;
	}

	/**
	 * New optimization will leave this filed for lazy evaluation. So check if this is empty before getting any
	 * access and if so download from the Item Cache.
	 */
	public EveItem getItem() {
		try {
			if ( null == itemCache ) {
				itemCache = accessGlobal().searchItem4Id(typeId);
			}
		} catch ( NeoComRuntimeException neoe ) {
			itemCache = new EveItem();
		}
		return itemCache;
	}

	public String getItemName() {
		return this.getItem().getName();
	}

	@Override
	public EveLocation getLocation() {
		try {
			if ( null == locationCache ) {
				locationCache = accessGlobal().searchLocation4Id(locationId);
			}
		} catch ( NeoComRuntimeException neoe ) {
			locationCache = new EveLocation();
		}
		return locationCache;
	}

	/**
	 * Return the location id of the asset. If the asset is in a container then the location is lost and the
	 * value is -1. In that cases we should search for the location on the parent asset if that exists.
	 */
	@Override
	public long getLocationId() {
		//		if (locationId == -1) {
		//			if (this.getParentContainerId() == -1)
		//				return -1L;
		//			else {
		//				// Get the location from the parent.
		//				final NeoComAsset par = this.getParentContainer();
		//				if (null == par)
		//					return -1L;
		//				else
		//					return par.getLocationId();
		//			}
		//		} else
		return locationId;
	}

	public String getName() {
		return name;
	}

	//	public String getOrderingName() {
	//		return name;
	//	}

	public long getOwnerId() {
		return ownerId;
	}

	public double getPrice() {
		return this.getItem().getPrice();
	}

	public int getQuantity() {
		return quantity;
	}

	public String getRegion() {
		return this.getLocation().getRegion();
	}

	public String getTech() {
		return this.getItem().getTech();
	}

	public int getTypeId() {
		return typeId;
	}

	public String getUserLabel() {
		return userLabel;
	}

	public boolean isBlueprint() {
		return blueprintFlag;
	}

	public boolean isContainer() {
		if ( this.isBlueprint() ) return false;
		// Use a list of types to set what is a container
		if ( this.getTypeId() == 11488 ) return true;
		if ( this.getTypeId() == 11489 ) return true;
		if ( this.getTypeId() == 11490 ) return true;
		if ( this.getTypeId() == 17363 ) return true;
		if ( this.getTypeId() == 17364 ) return true;
		if ( this.getTypeId() == 17365 ) return true;
		if ( this.getTypeId() == 17366 ) return true;
		if ( this.getTypeId() == 17367 ) return true;
		if ( this.getTypeId() == 17368 ) return true;
		if ( this.getTypeId() == 2263 ) return true;
		if ( this.getTypeId() == 23 ) return true;
		if ( this.getTypeId() == 24445 ) return true;
		if ( this.getTypeId() == 28570 ) return true;
		if ( this.getTypeId() == 3293 ) return true;
		if ( this.getTypeId() == 3296 ) return true;
		if ( this.getTypeId() == 3297 ) return true;
		if ( this.getTypeId() == 33003 ) return true;
		if ( this.getTypeId() == 33005 ) return true;
		if ( this.getTypeId() == 33007 ) return true;
		if ( this.getTypeId() == 33009 ) return true;
		if ( this.getTypeId() == 33011 ) return true;
		if ( this.getTypeId() == 3465 ) return true;
		if ( this.getTypeId() == 3466 ) return true;
		if ( this.getTypeId() == 3467 ) return true;
		if ( this.getTypeId() == 3468 ) return true;
		if ( this.getTypeId() == 41567 ) return true;
		if ( this.getTypeId() == 60 ) return true; // Asset Safety Wrap
		if ( this.getName().contains("Container") ) return true;
		if ( this.getName().contains("Wrap") ) return true;
		return false;
	}

	public boolean isPackaged() {
		return !isSingleton;
	}

	public boolean isShip() {
		return shipFlag;
	}

//	public boolean isShipFlag() {
//		return shipFlag;
//	}

	public NeoComAsset setAssetId(final long assetIdentifier) {
		assetId = assetIdentifier;
		return this;
	}

	public void setBlueprintType(final int rawQuantity) {
		if ( -1 == rawQuantity ) {
			this.setName(name + " (BPO)");
		} else {
			this.setName(name + " (BPC)");
		}
		blueprintFlag = true;
	}

	public void setCategory(final String category) {
		if ( null != category ) {
			this.category = category;
			if ( category.equalsIgnoreCase(ModelWideConstants.eveglobal.Ship) ) {
				shipFlag = true;
			}
		}
	}

	public void setContainer(final boolean value) {
		containerFlag = value;
	}

	//	public void setDirty( final boolean flag ) {
	//		if (flag) {
	//			try {
	//				final Dao<NeoComAsset, String> assetDao = accessGlobal().getNeocomDBHelper().getAssetDao();
	//				// Try to create the pair. It fails then  it was already created.
	//				assetDao.createOrUpdate(this);
	//			} catch (final SQLException sqle) {
	//				sqle.printStackTrace();
	//			}
	//		}
	//	}

	@Override
	public NeoComAsset setLocationFlag(final GetCharactersCharacterIdAssets200Ok.LocationFlagEnum newFlag) {
		this.locationFlag = newFlag;
		return this;
	}

	@Override
	public NeoComAsset setLocationFlag(final GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum newFlag) {
		this.locationFlag = GetCharactersCharacterIdAssets200Ok.LocationFlagEnum.valueOf(newFlag.name());
		return this;
	}

	public void setGroupName(final String name) {
		groupName = name;
	}

	public void setId(final long id) {
		this.id = id;
	}

	public void setIskValue(final double iskvalue) {
		iskValue = iskvalue;
	}

	@Override
	public NeoComAsset setLocationId(final long location) {
		locationId = location;
		locationCache = null;
		return this;
	}

	@Override
	public NeoComAsset setLocationType(final GetCharactersCharacterIdAssets200Ok.LocationTypeEnum locationType) {
		this.locationType = locationType;
		return this;
	}

	public void setName(final String name) {
		this.name = name;
	}

	public void setOwnerId(final long ownerId) {
		this.ownerId = ownerId;
	}


	public NeoComAsset setQuantity(final int count) {
		quantity = count;
		return this;
	}

	public void setShip(final boolean value) {
		shipFlag = value;
	}

	public void setShipFlag(final boolean shipFlag) {
		this.shipFlag = shipFlag;
	}

	public NeoComAsset setSingleton(final boolean newSingleton) {
		isSingleton = newSingleton;
		return this;
	}

	public void setTech(final String newTech) {
		tech = newTech;
	}

	public void setTypeId(final int newTypeId) {
		typeId = newTypeId;
	}

	public NeoComAsset setUserLabel(final String label) {
		if ( null != label ) {
			userLabel = label;
		}
		return this;
	}

	// --- I L O C A T A B L E    I N T E R F A C E

	/**
	 * This method usually return the parent container of an asset. This is valid when the asset is inside a
	 * container or a ship or any other asset, but when the asset is located on other corporation POCO or other
	 * unknown or unaccessible asset then this method fails to get the parent asset. <br>
	 * In that case we should replace the parent pointer to a new location pointer that gets stored into our new
	 * Locations table. With that change assets will be reallocated to a valid place and all code will
	 * understand the changes and behave correctly.
	 */
	@Override
	public NeoComAsset getParentContainer() {
		if ( parentAssetId > 0 ) if ( null == parentAssetCache ) {
			// Search for the parent asset. If not found then go to the transformation method.
			try {
				parentAssetCache = accessGlobal().getNeocomDBHelper().getAssetDao()
						.queryForId(Long.valueOf(parentAssetId).toString());
			} catch ( SQLException sqle ) {
				return null;
			}
		}
		return parentAssetCache;
	}

	@Override
	public long getParentContainerId() {
		return parentAssetId;
	}

	@Override
	public boolean hasParent() {
		if ( parentAssetId > 0 )
			return true;
		else
			return false;
	}

	@Override
	public void setParentContainer(final NeoComAsset newParent) {
		if ( null != newParent ) {
			parentAssetCache = newParent;
			parentAssetId = newParent.getAssetId();
			// Trigger an update of the record at the database.
			this.store();
		}
	}

	@Override
	public void setParentId(final long pid) {
		parentAssetId = pid;
	}

	/**
	 * Try to reduce the calls to methods to compose this information since that affects the code to be run.
	 */
	@Override
	public String toString() {
		final StringBuffer buffer = new StringBuffer("NeoComAsset [");
		buffer.append("#").append(typeId).append(" - ").append(this.getName()).append(" ");
		if ( null != this.getUserLabel() ) {
			buffer.append("[").append(this.getUserLabel()).append("] ");
		}
		buffer.append("itemID:").append(assetId).append(" ");
		buffer.append("locationID:").append(locationId).append(" ");
		buffer.append("containerID:").append(parentAssetId).append(" ");
		buffer.append("ownerId:").append(ownerId).append(" ");
		buffer.append("quantity:").append(quantity).append(" ");
		buffer.append("]\n");
		return buffer.toString();
	}

	/**
	 * Replaces a non reachable parent asset into an Unknown Location.
	 */
	private EveLocation moveAssetToUnknown(final long newlocationid) {
		final EveLocation newundefloc = new EveLocation();
		//		newundefloc.setId(newlocationid);
		newundefloc.setRegion("SPACE");
		newundefloc.setSystem("Undefined");
		newundefloc.setStation("Station#" + newlocationid);
		// Save this new location ot the database.
		//		try {
		//			Dao<EveLocation, String> locationDao = AppConnector.getDBConnector().getLocationDAO();
		//			// Try to create the pair. It fails then  it was already created.
		//			locationDao.createOrUpdate(newundefloc);
		//		} catch (final SQLException sqle) {
		//			sqle.printStackTrace();
		//			this.store(true);
		//		}
		return newundefloc;
	}
}
//- UNUSED CODE ............................................................................................
