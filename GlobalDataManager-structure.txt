GLOBALDATAMANAGER
	// - S T A T I C - S E C T I O N ..........................................................................
	// --- P U B L I C   E N U M E R A T O R S
	// --- P R I V A T E   E N U M E R A T O R S
	// --- E X C E P T I O N   L O G G I N G   S E C T I O N
	// --- E V E A P I   X M L   S E C T I O N --- Deprecated and removed
	// --- C O N F I G U R A T I O N   S E C T I O N
	// --- P R E F E R E N C E S   S E C T I O N
	// --- C A C H E   S T O R A G E   S E C T I O N
	// --- M A P P E R S   &   T R A N S F O R M E R S   S E C T I O N
	// --- M U L T I T H R E A D I N G   S E C T I O N
	// --- D A T A B A S E   A R E A
	// --- S D E   D A T A B A S E   S E C T I O N
	// --- P R I M A R Y    K E Y   C O N S T R U C T O R S
	// --- M A N A G E R - S T O R E   I N T E R F A C E --- Probably not required. Not sharable objects
	// --- N E T W O R K    D O W N L O A D   I N T E R F A C E --- Completes complex downloads should be kept secured


INFINITYGLOBALDATAMANAGER
	// --- M O D E L - S T O R E   I N T E R F A C E --- Is this the right place for this data and needs security?




NEOCOMGLOBALDATAMANAGER
	// --- N E O C O M   P R I V A T E   D A T A B A S E   S E C T I O N --- Only defined on the NeoCom project
	// --- M O D E L - S T O R E   I N T E R F A C E --- Not sharable objects
















	private static final Hashtable<ECacheTimes, Long> ESICacheTimes = new Hashtable();
	private static final long DEFAULT_CACHE_TIME = 600 * 1000;

	public enum ECacheTimes {
		CHARACTER_PUBLIC, CHARACTER_CLONES, PLANETARY_INTERACTION_PLANETS, PLANETARY_INTERACTION_STRUCTURES, ASSETS_ASSETS, CORPORATION_CUSTOM_OFFICES, UNIVERSE_SCHEMATICS, MARKET_PRICES
	}

	static {
		ESICacheTimes.put(ECacheTimes.CHARACTER_PUBLIC, TimeUnit.SECONDS.toMillis(3600));
		ESICacheTimes.put(ECacheTimes.CHARACTER_CLONES, TimeUnit.SECONDS.toMillis(200));
		ESICacheTimes.put(ECacheTimes.PLANETARY_INTERACTION_PLANETS, TimeUnit.SECONDS.toMillis(600));
		ESICacheTimes.put(ECacheTimes.PLANETARY_INTERACTION_STRUCTURES, TimeUnit.SECONDS.toMillis(600));
		ESICacheTimes.put(ECacheTimes.ASSETS_ASSETS, TimeUnit.SECONDS.toMillis(3600));
		ESICacheTimes.put(ECacheTimes.MARKET_PRICES, TimeUnit.SECONDS.toMillis(3600));
	}

	public static long getCacheTime4Type( final ECacheTimes selector ) {
		final Long hit = ESICacheTimes.get(selector);
		if (null == hit) return DEFAULT_CACHE_TIME;
		else return hit.longValue();
	}




	// --- N E O C O M   P R I V A T E   D A T A B A S E   S E C T I O N
	/**
	 * Reference to the NeoCom persistece database Dao provider. This filed should be injected on startup.
	 */
	private static INeoComDBHelper neocomDBHelper = null;

	public static INeoComDBHelper getNeocomDBHelper() {
		if (null == neocomDBHelper)
			throw new RuntimeException("[NeoComDatabase]> NeoCom database neocomDBHelper not defined. No access to platform library to get database results.");
		return neocomDBHelper;
	}

	public static void connectNeoComDBConnector( final INeoComDBHelper newhelper ) {
		if (null != newhelper) neocomDBHelper = newhelper;
		else
			throw new RuntimeException("[NeoComDatabase]> NeoCom database neocomDBHelper not defined. No access to platform library to get database results.");
	}

//	/**
//	 * Reads all the keys stored at the database and classifies them into a set of Login names.
//	 */
//	@Deprecated
//	public static List<ApiKey> accessAllApiKeys() {
//		logger.info(">> [GlobalDataManager.accessAllLogins]");
//		// Get access to all ApiKey registers
//		List<ApiKey> keyList = new Vector<ApiKey>();
//		try {
//			keyList = getNeocomDBHelper().getApiKeysDao().queryForAll();
//			// Extend the keys with some of the XML api information to get access to characters and credentials.
//			for (ApiKey key : keyList) {
//				key = GlobalDataManager.extendApiKey(key);
//			}
//		} catch (java.sql.SQLException sqle) {
//			sqle.printStackTrace();
//			logger.warn("W [GlobalDataManager.accessAllLogins]> Exception reading all Logins. " + sqle.getMessage());
//		} finally {
//			logger.info("<< [GlobalDataManager.accessAllLogins]");
//		}
//		return keyList;
//	}
//	private static ApiKey extendApiKey( ApiKey basekey ) {
//		// Check if this request is already available on the cache.
//		try {
//			// Get the ApiKey Information block.
//			ApiAuthorization authorization = new ApiAuthorization(basekey.getKeynumber(), basekey.getValidationcode());
//			ApiKeyInfoParser infoparser = new ApiKeyInfoParser();
//			ApiKeyInfoResponse inforesponse = infoparser.getResponse(authorization);
//			if (null != inforesponse) {
//				basekey.setAuthorization(authorization)
//						.setDelegated(inforesponse.getApiKeyInfo());
//				//				.setCachedUntil(inforesponse.getCachedUntil());
//				return basekey;
//			}
//		} catch (ApiException apie) {
//			apie.printStackTrace();
//		}
//		return basekey;
//	}

	/**
	 * Reads all the list of credentials stored at the Database and returns them. Activation depends on the
	 * interpretation used by the application.
	 */
	public static List<Credential> accessAllCredentials() {
		List<Credential> credentialList = new ArrayList<>();
		try {
//			final Dao<Credential, String> credentialDao = GlobalDataManager.getNeocomDBHelper().getCredentialDao();
//			final PreparedQuery<Credential> preparedQuery = credentialDao.queryBuilder().prepare();
//			credentialList = credentialDao.query(preparedQuery);
			credentialList = GlobalDataManager.getNeocomDBHelper().getCredentialDao().queryForAll();
		} catch (java.sql.SQLException sqle) {
			sqle.printStackTrace();
			logger.warn("W [GlobalDataManager.accessAllCredentials]> Exception reading all Credentials. " + sqle.getMessage());
		}
		return credentialList;
	}

	/**
	 * Reads the list of Colonies for the identified Credential from the persistence database. Inthe case there are no
	 * records the method checks the TimeStamp to verify that the Downloader is working on this demand and if
	 * the timer has elapsed or there is no TS, forces a first download directly throught the Network.
	 *
	 * @param credential
	 * @return
	 */
	public static List<Colony> accessColonies4Credential( final Credential credential ) {
		logger.info(">> [GlobalDataManager.accessColonies4Credential]> Credential: {}", credential.getAccountName());
		List<Colony> colonyList = new ArrayList<>();
		try {
			// SELECT * FROM COLONY WHERE OWNERID = <identifier>
			Dao<Colony, String> colonyDao = getNeocomDBHelper().getColonyDao();
			QueryBuilder<Colony, String> queryBuilder = colonyDao.queryBuilder();
			Where<Colony, String> where = queryBuilder.where();
			where.eq("ownerID", credential.getAccountId());
			PreparedQuery<Colony> preparedQuery = queryBuilder.prepare();
			colonyList = colonyDao.query(preparedQuery);

			// Check the number of registers. If they are zero then we have to perform additional checks.
			if (colonyList.size() < 1) {
				// Check if there is a valid TS.
				final String reference = constructJobReference(EDataUpdateJobs.COLONYDATA, credential.getAccountId());
				final TimeStamp ts = GlobalDataManager.getNeocomDBHelper().getTimeStampDao().queryForId(reference);
				if (null == ts) {
					// No time stamp so force a request for this data now.
					return GlobalDataManager.downloadColonies4Credential(credential);
				} else {
					// Check time stamp if elapsed.
					if (ts.getTimeStamp() < Instant.now().getMillis())
						return GlobalDataManager.downloadColonies4Credential(credential);
				}
			}

			// Add pending downloaded information.
			for (Colony col : colonyList) {
				final List<ColonyStructure> struc = accessColonyStructures4Planet(credential.getAccountId(), col.getPlanetId());
				// Check that the structures have been stored at the database. If this fails go to download them.
				if (struc.size() < 1)
					col.setStructures(downloadStructures4Colony(credential.getAccountId(), col.getPlanetId()));
				else col.setStructures(struc);
			}
		} catch (SQLException sqle) {
			sqle.printStackTrace();
			logger.warn("W [GlobalDataManager.accessColonies4Credential]> Exception reading Colonies. " + sqle.getMessage());
		} finally {
			logger.info("<< [GlobalDataManager.accessColonies4Credential]");
		}
		return colonyList;
	}

	public static List<ColonyStructure> accessColonyStructures4Planet( final int identifier, final int planet ) {
		logger.info(">> [GlobalDataManager.accessColonyStructures4Planet]");
		List<ColonyStructure> structureList = new ArrayList<>();
		try {
			try {
				// Compose the unique key reference.
				final String ref = constructPlanetStorageIdentifier(identifier, planet);
				logger.info(">> [GlobalDataManager.accessColonyStructures4Planet]> Structure reference: {}", ref);
				// SELECT * FROM ColonyStorage WHERE planetIdentifier = <identifier>
				final List<ColonyStorage> structureData = GlobalDataManager.getNeocomDBHelper()
						.getColonyStorageDao().queryForEq("planetIdentifier", ref);
				if (null != structureData) {
					for (ColonyStorage storage : structureData) {
						// Reconstruct the structure from the serialized data.
						final ColonyStructure structure = jsonMapper.readValue(storage.getColonySerialization(), ColonyStructure.class);
						structureList.add(structure);
					}
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		} catch (SQLException sqle) {
			sqle.printStackTrace();
			logger.warn("W [GlobalDataManager.accessColonyStructures4Planet]> Exception reading Colonies. " + sqle.getMessage());
		} finally {
			logger.info("<< [GlobalDataManager.accessColonyStructures4Planet]");
		}
		return structureList;
	}

	public static ArrayList<NeoComAsset> accessAssetsContainedAt( final long characterID, final long containerId ) {
		return accessAssetsContainedAt(containerId);
	}

	public static ArrayList<NeoComAsset> accessAssetsContainedAt( final long containerId ) {
		// Select assets for the owner and with an specific type id.
		List<NeoComAsset> assetList = new ArrayList<NeoComAsset>();
		try {
			// TODO Another and more simple way to execute the command.
			assetList = getNeocomDBHelper().getAssetDao().queryForEq("parentAssetID", Long.valueOf(containerId).toString());
			//			Dao<NeoComAsset, String> assetDao = getNeocomDBHelper().getAssetDao();
			//			QueryBuilder<NeoComAsset, String> queryBuilder = assetDao.queryBuilder();
			//			Where<NeoComAsset, String> where = queryBuilder.where();
			//			// TODO Check if this gives the same results because a container only can belong to an owner. If we have the
			//			// identifier then we should be the owner or being using that credential.
			////			where.eq("ownerID", characterID);
			////			where.and();
			//			where.eq("parentAssetID", containerId);
			//			PreparedQuery<NeoComAsset> preparedQuery = queryBuilder.prepare();
			//			assetList = assetDao.query(preparedQuery);
		} catch (java.sql.SQLException sqle) {
			sqle.printStackTrace();
		}
		return (ArrayList<NeoComAsset>) assetList;
	}

	/**
	 * Get the complete list of assets that are Planetary Materials.
	 *
	 * @return
	 */
	public static ArrayList<NeoComAsset> accessAllPlanetaryAssets( final long characterID ) {
		// Select assets for each one of the Planetary categories.
		ArrayList<NeoComAsset> assetList = new ArrayList<NeoComAsset>();
		assetList.addAll(GlobalDataManager.searchAsset4Category(characterID, "Planetary Commodities"));
		assetList.addAll(GlobalDataManager.searchAsset4Category(characterID, "Planetary Resources"));
		return assetList;
	}

	/**
	 * Gets the list of assets of a select Category for the identified owner.
	 *
	 * @param characterID  - owner of the assets.
	 * @param categoryName - the category name to search for.
	 * @return
	 */
	public static List<NeoComAsset> searchAsset4Category( final long characterID, final String categoryName ) {
		// Select assets for the owner and with an specific type id.
		List<NeoComAsset> assetList = new ArrayList<NeoComAsset>();
		Chrono timeLapse = new Chrono();
		try {
			Dao<NeoComAsset, String> assetDao = GlobalDataManager.getNeocomDBHelper().getAssetDao();
			QueryBuilder<NeoComAsset, String> queryBuilder = assetDao.queryBuilder();
			Where<NeoComAsset, String> where = queryBuilder.where();
			where.eq("ownerID", characterID);
			where.and();
			where.eq("category", categoryName);
			PreparedQuery<NeoComAsset> preparedQuery = queryBuilder.prepare();
			assetList = assetDao.query(preparedQuery);
			logger.info("~~ [AndroidDatabaseConnector.searchAsset4Category]> Time lapse for [SELECT CATEGORY=" + categoryName
					+ " OWNERID = " + characterID + "] - " + timeLapse.printElapsed(Chrono.ChronoOptions.SHOWMILLIS));
		} catch (java.sql.SQLException sqle) {
			sqle.printStackTrace();
		}
		return assetList;
	}

	/**
	 * Gets the assets located at an specific position by checking the pilot identifier and the asset reference
	 * to a location stored at the <code>locationID</code> column value. We also filter out the assets that even
	 * are located at the searched place they are inside another asset, like ships or containers.
	 *
	 * @param ownerid
	 * @param identifier
	 * @return
	 */
	public static List<NeoComAsset> searchAssetsAtLocation( final long ownerid, final long identifier ) {
		// Get access to one assets with a distinct location. Discard the rest of the data and only process the Location id
		List<NeoComAsset> contents = new Vector<NeoComAsset>();
		try {
			Dao<NeoComAsset, String> assetDao = GlobalDataManager.getNeocomDBHelper().getAssetDao();
			QueryBuilder<NeoComAsset, String> queryBuilder = assetDao.queryBuilder();
			Where<NeoComAsset, String> where = queryBuilder.where();
			where.eq("ownerID", ownerid);
			where.and().eq("locationID", identifier);
			where.and().eq("parentAssetId", -1);
			PreparedQuery<NeoComAsset> preparedQuery = queryBuilder.prepare();
			contents = assetDao.query(preparedQuery);
		} catch (java.sql.SQLException sqle) {
			sqle.printStackTrace();
			logger.warn("W [NeoComBaseDatabase.queryLocationContents]> Exception reading Location contents" + sqle.getMessage());
		}
		return contents;
	}

	/**
	 * Returns the number of items that are located at the specified location. There is another filter for the
	 * character owner of the assets.
	 *
	 * @param identifier
	 * @return
	 */
	public static int totalLocationContentCount( final long identifier ) {
		try {
			Dao<NeoComAsset, String> assetDao = GlobalDataManager.getNeocomDBHelper().getAssetDao();
			QueryBuilder<NeoComAsset, String> queryBuilder = assetDao.queryBuilder();
			queryBuilder.setCountOf(true).where().eq("locationID", identifier);
			long totalAssets = assetDao.countOf(queryBuilder.prepare());
			return Long.valueOf(totalAssets).intValue();
		} catch (java.sql.SQLException sqle) {
			sqle.printStackTrace();
			logger.warn("W [NeoComBaseDatabase.getLocationContentCount]> Exception reading Location contents count."
					+ sqle.getMessage());
			return 0;
		}
	}





	// --- M A N A G E R - S T O R E   I N T E R F A C E
	private static final ManagerOptimizedCache managerCache = new ManagerOptimizedCache();

	public static AssetsManager getAssetsManager( final Credential credential ) {
		return GlobalDataManager.getAssetsManager(credential, false);
	}

	public static AssetsManager getAssetsManager( final Credential credential, final boolean forceNew ) {
		// Check if this request is already available on the cache.
		final AssetsManager hit = (AssetsManager) managerCache.access(EManagerCodes.ASSETS_MANAGER, credential.getAccountId());
		if ((null == hit) || (forceNew)) {
			final AssetsManager manager = new AssetsManager(credential);
			managerCache.store(EManagerCodes.ASSETS_MANAGER, manager, credential.getAccountId());
			return manager;
		} else return hit;
	}

	public static AssetsManager dropAssetsManager( final long identifier ) {
		return (AssetsManager) managerCache.delete(EManagerCodes.ASSETS_MANAGER, identifier);
	}

	public static PlanetaryManager getPlanetaryManager( final Credential credential ) {
		return getPlanetaryManager(credential, false);
	}

	public static PlanetaryManager getPlanetaryManager( final Credential credential, final boolean forceNew ) {
		// Check if this request is already available on the cache.
		final PlanetaryManager hit = (PlanetaryManager) managerCache.access(EManagerCodes.PLANETARY_MANAGER, credential.getAccountId());
		if ((null == hit) || (forceNew)) {
			// TODO This line depends on the architecture of the data loading when it should not.
			final PlanetaryManager manager = new PlanetaryManager(credential);
			managerCache.store(EManagerCodes.PLANETARY_MANAGER, manager, credential.getAccountId());
			return manager;
		} else return hit;
	}

	public static PlanetaryManager dropPlanetaryManager( final long identifier ) {
		return (PlanetaryManager) managerCache.delete(EManagerCodes.PLANETARY_MANAGER, identifier);
	}




	// --- M O D E L - S T O R E   I N T E R F A C E
	private static final ModelTimedCache modelCache = new ModelTimedCache();

	/**
	 * Activated the selected credential as the active Credential. This will also point to the current Character but
	 * allows for lazy evaluation of most of the Character data to be obtained when the character is later used on the
	 * interfaces.
	 *
	 * @param identifier unique account number of character identifier.
	 * @return the new credential made active. Raises a RuntimeException if the Credential is not found.
	 */
	public static Credential searchCredential4Id( final long identifier ) throws NeoComException {
		// Get the list of current registered creentials.
		final List<Credential> credentials = GlobalDataManager.accessAllCredentials();
		// Search for the credential on the list.
		for (Credential target : credentials)
			if (target.getAccountId() == identifier) return target;
		// If we reach this point this means that we have not found the credential. This is an exception.
		throw new NeoComException("RT [GlobalDataManager]> Credential with id " + identifier + " not found.");
	}

	/**
	 * Construct a minimal implementation of a Pilot from the XML api. This will get deprecated soon but during
	 * some time It will be compatible and I will have a better view of what variants are being used.
	 * <p>
	 * Once the XML api is deprecated we implement the Pilot version 2. This will replace old data structures by its equivalents
	 * and also add new data and dependencies. This is the most up to date evolver version and comes from the Infinity requirements.
	 *
	 * @param identifier character identifier from the valid Credential.
	 * @return an instance of a PilotV1 class that has some of the required information to be shown on the ui at this
	 * point.
	 */
	public static PilotV2 getPilotV2( final int identifier, final SessionContext context ) {
		logger.info(">> [GlobalDataManager.getPilotV2]> Identifier: {}", identifier);
		try {
			// Check if this request is already available on the cache.
			final ICollaboration hit = modelCache.access(EModelVariants.PILOTV2, identifier);
			if (null == hit) {
				logger.info("-- [GlobalDataManager.getPilotV2]> Instance not found at cache. Downloading pilot <{}> info.", identifier);
				final PilotV2 newchar = new PilotV2();
				// Get the credential from the Store and check if this identifier has access to the XML api.
				final Credential credential = context.getCredential();
				if (null != credential) {
					logger.info("-- [GlobalDataManager.getPilotV2]> Processing data with Credential <{}>.", credential.getAccountName());

					// Public information.
					logger.info("-- [GlobalDataManager.getPilotV2]> ESI Compatible. Download public data information.");
					final GetCharactersCharacterIdOk publicData = ESINetworkManager.getCharactersCharacterId(Long.valueOf(identifier).intValue()
							, credential.getRefreshToken()
							, SERVER_DATASOURCE);
					newchar.setPublicData(publicData);
					// Process the public data and get the referenced instances for the Corporation, race, etc.
					newchar.setCorporation ( GlobalDataManager.useCorporationV1(publicData.getCorporationId(),context))
					.setAlliance (GlobalDataManager.useAllianceV1(publicData.getAllianceId(),context))
					.setRace (GlobalDataManager.searchSDERace(publicData.getRaceId(),context))
					.setBloodline (GlobalDataManager.searchSDEBloodline(publicData.getBloodlineId(),context))
					.setAncestry (GlobalDataManager.searchSDEAncestry(publicData.getAncestryId(),context));

					// Clone data
					logger.info("-- [GlobalDataManager.getPilotV2]> ESI Compatible. Download clone information.");
					final GetCharactersCharacterIdClonesOk cloneInformation = ESINetworkManager.getCharactersCharacterIdClones(Long.valueOf(identifier).intValue(), credential.getRefreshToken(), "tranquility");
					if (null != cloneInformation) {
						newchar.setCloneInformation(cloneInformation);
						newchar.setHomeLocation(cloneInformation.getHomeLocation());
					}

					// Roles
					// TODO To be implemented
					// Register instance into the cache. Expiration time is about 3600 seconds.
					try {
						final Instant expirationTime = Instant.now().plus(TimeUnit.SECONDS.toMillis(3600));
						modelCache.store(EModelVariants.PILOTV2, newchar, expirationTime, identifier);
						// Store this same information on the database to record the TimeStamp.
						final String reference = GlobalDataManager.constructModelStoreReference(GlobalDataManager.EDataUpdateJobs.CHARACTER_CORE, credential.getAccountId());
						TimeStamp timestamp = getNeocomDBHelper().getTimeStampDao().queryForId(reference);
						if (null == timestamp) timestamp = new TimeStamp(reference, expirationTime);
						logger.info("-- [GlobalDataManager.getPilotV2]> Updating character TimeStamp {}.", reference);
						timestamp.setTimeStamp(expirationTime)
								.setCredentialId(credential.getAccountId())
								.store();
					} catch (SQLException sqle) {
						sqle.printStackTrace();
					}
				}
				return newchar;
			} else {
				logger.info("-- [GlobalDataManager.getPilotV2]> Pilot <{}> found at cache.", identifier);
				return (PilotV2) hit;
			}
		} finally {
			logger.info("<< [GlobalDataManager.getPilotV2]");
		}
	}

	public static boolean checkPilotV1( final int identifier ) {
		final ICollaboration hit = modelCache.access(EModelVariants.PILOTV1, identifier);
		if (null == hit) return false;
		else return true;
	}

//	/**
//	 * Deletes the current entry if found and forces a new download.
//	 *
//	 * @param identifier the pilot identifier to load.
//	 * @return
//	 */
//	public static PilotV2 udpatePilotV2( final int identifier ) {
//		logger.info(">> [GlobalDataManager.udpatePilotV2]");
//		try {
//			final ICollaboration hit = modelCache.access(EModelVariants.PILOTV2, identifier);
//			if (null != hit) modelCache.delete(EModelVariants.PILOTV1, identifier);
//			return getPilotV2(identifier);
//		} finally {
//			logger.info("<< [GlobalDataManager.udpatePilotV2]");
//		}
//	}

	//--- CORPORATION
	public static CorporationV1 useCorporationV1( final int identifier, final SessionContext context ) {
		logger.info(">> [GlobalDataManager.useCorporationV1]> Identifier: {}", identifier);
		try {
			// Check if this request is already available on the cache.
			final ICollaboration hit = modelCache.access(EModelVariants.CORPORATIONV1, identifier);
			if (null == hit) {
				logger.info("-- [GlobalDataManager.useCorporationV1]> Instance not found at cache. Downloading Corporation <{}> info.",
						identifier);
				final CorporationV1 newcorp = new CorporationV1();
				// Get the credential from the Store.
				final Credential credential = context.getCredential();

				// Corporation information.
				logger.info("-- [GlobalDataManager.useCorporationV1]> ESI Compatible. Download corporation information.");
				final GetCorporationsCorporationIdOk publicData = ESINetworkManager.getCorporationsCorporationId(Long.valueOf(identifier).intValue()
						, credential.getRefreshToken()
						, SERVER_DATASOURCE);
				newcorp.setPublicData(publicData);
				// Process the public data and get the referenced instances for the Corporation, race, etc.
				newcorp.setAlliance(GlobalDataManager.useAllianceV1(publicData.getAllianceId(), context));

				return newcorp;
			} else {
				logger.info("-- [GlobalDataManager.useCorporationV1]> Corporation <{}> found at cache.", identifier);
				return (CorporationV1) hit;
			}
		} finally {
			logger.info("<< [GlobalDataManager.useCorporationV1]");
		}
	}

	//--- ALLIANCE
	public static AllianceV1 useAllianceV1( final int identifier, final SessionContext context ) {
		logger.info(">> [GlobalDataManager.useAllianceV1]> Identifier: {}", identifier);
		try {
			// Check if this request is already available on the cache.
			final ICollaboration hit = modelCache.access(EModelVariants.ALLIANCEV1, identifier);
			if (null == hit) {
				logger.info("-- [GlobalDataManager.useAllianceV1]> Instance not found at cache. Downloading Alliance <{}> info.",
						identifier);
				final AllianceV1 newalliance = new AllianceV1();
				// Get the credential from the Store.
				final Credential credential = context.getCredential();

				// Corporation information.
				logger.info("-- [GlobalDataManager.useAllianceV1]> ESI Compatible. Download corporation information.");
				final GetAlliancesAllianceIdOk publicData = ESINetworkManager.getAlliancesAllianceId(Long.valueOf(identifier).intValue()
						, credential.getRefreshToken()
						, SERVER_DATASOURCE);
				newalliance.setPublicData(publicData);
				return newalliance;
			} else {
				logger.info("-- [GlobalDataManager.useAllianceV1]> Alliance <{}> found at cache.", identifier);
				return (AllianceV1) hit;
			}
		} finally {
			logger.info("<< [GlobalDataManager.useAllianceV1]");
		}
	}
